# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
path = "exercises/move_semantics/move_semantics1.cairo"
mode = "compile"
hint = """
So you've got the "ref argument must be a mutable variable." error on line 17,
right? The fix for this is going to be adding one keyword, and the addition is NOT on line 17
where the error is.

Also: Try accessing `arr0` after having called `fill_arr()`. See what happens!"""

[[exercises]]
name = "move_semantics2"
path = "exercises/move_semantics/move_semantics2.cairo"
mode = "compile"
hint = """
So, `arr0` is passed into the `fill_arr` function as an argument. In Cairo,
when an argument is passed to a function and it's not explicitly returned,
you can't use the original variable anymore. We call this "moving" a variable.
Variables that are moved into a function (or block scope) and aren't explicitly
returned get "dropped" at the end of that function. This is also what happens here.
There's a few ways to fix this, try them all if you want:
1. Make another, separate version of the data that's in `arr0` and pass that
   to `fill_arr` instead.
2. Make `fill_arr` *mutably* borrow a reference to its argument (which will need to be
   mutable) with the `ref` keyword , modify it directly, then not return anything. Then you can get rid
   of `arr1` entirely -- note that this will change what gets printed by the
   first `print`
3. Make `fill_arr` borrow an immutable view of its argument instead of taking ownership by using the snapshot operator `@`,
   and then copy the data within the function in order to return an owned
   `Array<felt>`. This requires an explicit clone of the array and should generally be avoided in Cairo, as the memory is write-once and cloning can be expensive."""

[[exercises]]
name = "move_semantics3"
path = "exercises/move_semantics/move_semantics3.cairo"
mode = "compile"
hint = """
The difference between this one and the previous ones is that the first line
of `fn fill_arr` that had `let mut arr = arr;` is no longer there. You can,
instead of adding that line back, add `mut` in one place that will change
an existing binding to be a mutable binding instead of an immutable one :)"""

[[exercises]]
name = "move_semantics4"
path = "exercises/move_semantics/move_semantics4.cairo"
mode = "compile"
hint = """
Stop reading whenever you feel like you have enough direction :) Or try
doing one step and then fixing the compiler errors that result!
So the end goal is to:
   - get rid of the first line in main that creates the new array
   - so then `arr0` doesn't exist, so we can't pass it to `fill_arr`
   - we don't want to pass anything to `fill_arr`, so its signature should
     reflect that it does not take any arguments
   - since we're not creating a new vec in `main` anymore, we need to create
     a new vec in `fill_arr`, similarly to the way we did in `main`"""

[[exercises]]
name = "move_semantics5"
path = "exercises/move_semantics/move_semantics5.cairo"
mode = "compile"
hint = """
Carefully reason about how each function takes ownership of the variable passed.
It depends on the keyword used to pass the variable.
What happens when a function takes ownership of a variable and then returns it?
Can we still use it later on?
"""

[[exercises]]
name = "move_semantics6"
path = "exercises/move_semantics/move_semantics6.cairo"
mode = "compile"
hint = """
The first problem is that `get_value` is taking ownership of the Number struct.
So `Number` is moved and can't be used for `set_value`
`number` is moved to `get_value` first, meaning that `set_value` cannot manipulate the data.
What can we use to pass an immutable reference to `get_value`? What special operator do we use for that?
What other operator do we use to "desnap" a snapshot?
Hint: It involves the `@` and `*` operators.

Once you've fixed that, `set_value`'s function signature will also need to be adjusted.
Can you figure out how?
"""

# TRAITS

[[exercises]]
name = "traits1"
path = "exercises/traits/traits1.cairo"
mode = "test"
hint = """ 
If you want to implement a trait for a type, you have to implement all the methods in the trait.
Based on the signature of the method, you can easily implement it.

In the test, you need to instantiate two objects of type `Animal`.
You can call the method of a trait by using the MyTrait::foo() syntax.
How would you instantiate the two objects with AnimalTrait?
Maybe you need to specify the type of the object?
"""

[[exercises]]
name = "traits2"
path = "exercises/traits/traits2.cairo"
mode = "test"
hint = """ No hints for this one! It is very similar to the previous exercise."""

[[exercises]]
name = "traits3"
path = "exercises/traits/traits3.cairo"
mode = "test"
hint = """ 
You can implement multiple traits for a type.
When a trait is destined to be implemented by a single type, you don't need to use generics.
If you're having trouble updating the distance value in the `Fish` and `Dog` impls, remember that you need to first
1. Destructure the object into mutable variables
2. Update the distance variable
3. Reconstruct `self` with the updated variables (`self = MyStruct { ... }`) 
"""
